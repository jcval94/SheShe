---
layout: default
title: RegionInterpreter
parent: SheShe
nav_order: 4
---
<link rel="stylesheet" href="style.css">
<script src="lang.js"></script>
<div class="lang-switch"><a href="regioninterpreter_es.html">ES</a></div>

<h1>RegionInterpreter</h1>

<pre><code>
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sheshe import ModalBoundaryClustering, RegionInterpreter

iris = load_iris()
X, y = iris.data, iris.target
sh = ModalBoundaryClustering().fit(X, y)
cards = RegionInterpreter(feature_names=iris.feature_names).summarize(sh.regions_)
sh.plot_pairs(X, y, max_pairs=1, show_histograms=True)
plt.show()
</code></pre>
<p>Converts <code>ClusterRegion</code> objects into compact human‑readable rule sets.</p>
<p>It summarises each region with axis‑aligned boxes, highlights informative</p>
<p>projections and offers helpers like <code>pretty_print</code> for reporting. Optional</p>
<p>LLM backends can turn the summaries into natural‑language descriptions.</p>
<h2>Mathematical formulation</h2>
<p>For each feature <code>j</code>, an axis‑aligned rule uses quantiles <code>[Q_q(x_j), Q_{1-q}(x_j)]</code>, capturing about <code>1-2q</code> of the data.</p>
<p>Capped radii are flagged using the z‑score <code>z=(r-μ)/σ</code> when <code>|z| &gt; cap_threshold</code>.</p>
<p><strong>Example:</strong> with <code>q_box=0.05</code> and values 1‑10, the rule becomes <code>[1.45, 9.55]</code>. A radius 3 with mean 2 and <code>σ=0.3</code> yields <code>z≈3.3</code>.</p>
<h2>Example</h2>
<pre><code class="language-python">
from sheshe import RegionInterpreter
ri = RegionInterpreter(feature_names=["sepal", "petal"])
summary = ri.summarize(region)
</code></pre>

<h2>Usage examples</h2>
<pre><code class="language-python">
from sheshe import RegionInterpreter

ri = RegionInterpreter(feature_names=["sepal", "petal"])
ri.summarize(region)       # summarize a single region
ri.summarize([region])     # summarize a list of regions
</code></pre>
<h2>Additional examples</h2>
<pre><code class="language-python">
from sklearn.datasets import load_iris
from sheshe import ModalBoundaryClustering, RegionInterpreter

iris = load_iris()
X, y = iris.data, iris.target

sh = ModalBoundaryClustering().fit(X, y)
cards = RegionInterpreter(feature_names=iris.feature_names).summarize(sh.regions_)
RegionInterpreter.pretty_print(cards[:1])
</code></pre>
<h2>Parameters</h2>
<ul>
<li><code>feature_names</code> (<code>list[str]</code> or <code>None</code>, default <code>None</code>): names for each
 feature used in the generated rules.
</li>
<li><code>q_box</code> (<code>float</code>, default <code>0.05</code>): quantile used to compute robust axis-aligned
 boxes.
</li>
<li><code>k_pairs</code> (<code>int</code>, default <code>2</code>): number of informative 2D projections to
 include.
</li>
<li><code>decimals</code> (<code>int</code>, default <code>2</code>): decimal precision in the emitted rules.
</li>
<li><code>cap_threshold</code> (<code>float</code>, default <code>6.393</code>): z-score threshold to mark capped
 radii.
</li>
<li><code>near_const_tol</code> (<code>float</code>, default <code>0.12</code>): tolerance to report nearly constant
 dimensions.
</li>
<li><code>inverse_transform</code> (callable, optional): function applied to points before
 rule extraction (e.g. inverse scaling).
</li>
<li><code>feature_bounds</code> (<code>Sequence[Tuple[float, float]]</code> or <code>None</code>): hard bounds for
 each feature to clamp boxes.
</li>
<li><code>include_center_in_box</code> (<code>bool</code>, default <code>True</code>): include region centre when
 computing axis-aligned boxes.
</li>
</ul>
<h2>Methods</h2>
<ul>
<li><code>summarize(regions)</code> – return a list of dictionaries containing headlines,
 axis-aligned rules and pairwise projections for the provided regions.
</li>
</ul>
