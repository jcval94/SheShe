---
layout: default
title: ShuShu
parent: SheShe
nav_order: 5
---
<link rel="stylesheet" href="style.css">

<h1>ShuShu</h1>

<figure class="doc-image">
  <img src="images/shushu.png" alt="ShuShu diagram">
</figure>
<p>Gradient-based optimiser that searches for local maxima of a scalar score or</p>
<p>class probabilities. Runs one optimisation per class when labels are given and</p>
<p>can also operate on arbitrary user-defined score functions, returning cluster</p>
<p>centroids for each discovered mode.</p>
<h2>Example</h2>
<pre><code class="language-python">
from sheshe import ShuShu
ss = ShuShu()
ss.fit(X, y)
labels = ss.predict(X)
</code></pre>

<h2>Usage examples</h2>
<pre><code class="language-python">
from sheshe import ShuShu

shu = ShuShu(random_state=0)
shu.fit(X, y)                      # fit
shu.fit_predict(X, y)              # fit_predict
shu.fit_transform(X, y)            # fit_transform
shu.fit(X, y).transform(X)         # transform
shu.fit(X, y).predict(X)           # predict
shu.fit(X, y).predict_proba(X)     # predict_proba
shu.fit(X, y).decision_function(X) # decision_function
shu.fit(X, y).predict_regions(X)   # predict_regions
shu.fit(X, y).score(X, y)          # score
shu.fit(X, y).save("shu.joblib")   # save
ShuShu.load("shu.joblib")
</code></pre>
<h2>Additional examples</h2>
<pre><code class="language-python">
from sklearn.datasets import load_iris
from sheshe import ShuShu

X, y = load_iris(return_X_y=True)
sh = ShuShu(random_state=0).fit(X, y)
print(sh.summary_tables()[0][["class_label", "n_clusters"]])

import numpy as np
def paraboloid(Z):
    return -np.linalg.norm(Z - 1.0, axis=1)

sc = ShuShu(random_state=0).fit(np.random.rand(100, 2), score_fn=paraboloid)
print(sc.centroids_)
</code></pre>
<h2>Parameters</h2>
<ul>
<li><code>clusterer_factory</code> (callable or <code>None</code>, default <code>None</code>): factory returning
 the internal optimiser. When <code>None</code> a default implementation is used.
</li>
<li><code>random_state</code> (<code>int</code> or <code>None</code>, default <code>None</code>): seed for reproducibility.
</li>
<li><code>**clusterer_kwargs</code> – additional arguments forwarded to the internal
 optimiser.
</li>
</ul>
<h2>Methods</h2>
<ul>
<li><code>fit(X, y=None, score_fn=None, ...)</code> – fit the optimiser. When <code>y</code> is
 provided, the score function is learned per class; otherwise <code>score_fn</code>
 must be supplied.
</li>
<li><code>fit_predict(X, y=None, **kwargs)</code> – convenience wrapper calling <code>fit</code> then
 <code>predict</code>.
</li>
<li><code>predict(X)</code> – return class labels or cluster ids.
</li>
<li><code>predict_proba(X)</code> – class probabilities (after fitting with labels).
</li>
<li><code>decision_function(X)</code> – raw decision scores.
</li>
<li><code>transform(X)</code> – membership/affinity matrix.
</li>
<li><code>fit_transform(X, y=None, **kwargs)</code> – combine <code>fit</code> and <code>transform</code>.
</li>
<li><code>plot_pairs(X, y=None, max_pairs=None)</code> – scatter plots for feature pairs.
</li>
<li><code>plot_classes(X, y, grid_res=200, contour_levels=None, max_paths=20,
 show_paths=True)</code> – visualise class-wise score surfaces.
</li>
<li><code>plot_pair_3d(X, y=None, features=(i, j), ax=None, fig=None, grid=64)</code> – 3D
 surface rendering of the score function.
</li>
<li><code>get_cluster(cluster_id, with_geometry=False)</code> – retrieve information about a
 discovered cluster.
</li>
</ul>
